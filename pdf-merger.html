<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Merge PDFs easily with page preview, rotation, and drag-and-drop reorder. Free online PDF tool with monetization support via AdSense." />
  <title>PDF Merger Tool | Merge, Rotate, Reorder</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    body { background: #f4f7fa; color: #333; }
    header { background: #4a90e2; padding: 1.5rem; color: white; text-align: center; }
    .container { max-width: 1000px; margin: auto; padding: 2rem; }
    .uploader { background: white; border: 2px dashed #ccc; padding: 2rem; text-align: center; cursor: pointer; margin-bottom: 2rem; }
    .preview-container { display: flex; flex-wrap: wrap; gap: 1rem; justify-content: center; }
    .page-preview { border: 1px solid #ccc; border-radius: 8px; padding: 1rem; background: #fff; position: relative; cursor: move; }
    .page-preview canvas { display: block; margin-bottom: 0.5rem; width: 120px; }
    .controls { display: flex; gap: 0.5rem; justify-content: center; }
    .controls button { padding: 0.3rem 0.6rem; font-size: 0.8rem; cursor: pointer; }
    .merge-controls { text-align: center; margin: 2rem 0; }
    .merge-controls select, .merge-controls button { padding: 0.5rem; font-size: 1rem; margin: 0.5rem; }
    .ad-section { margin: 3rem 0; text-align: center; }
    footer { text-align: center; padding: 1.5rem; background: #333; color: white; }
    .quality-options { margin: 1rem 0; }
    .quality-options label { margin-right: 1rem; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</head>
<body>
  <header>
    <h1>PDF Merger</h1>
    <p>Preview pages, rotate, and reorder before merging.</p>
  </header>

  <div class="container">
    <div class="uploader" id="drop-zone">
      <p>Click or Drag PDF files here to upload</p>
      <input type="file" id="file-input" accept="application/pdf" multiple hidden />
    </div>

    <div class="quality-options">
      <label>Output Quality:</label>
      <input type="radio" id="quality-high" name="quality" value="high" checked>
      <label for="quality-high">High</label>
      <input type="radio" id="quality-medium" name="quality" value="medium">
      <label for="quality-medium">Medium</label>
      <input type="radio" id="quality-low" name="quality" value="low">
      <label for="quality-low">Low</label>
    </div>

    <div class="preview-container" id="preview-container"></div>

    <div class="merge-controls">
      <label for="page-size">Page Size:</label>
      <select id="page-size">
        <option value="A4">A4</option>
        <option value="LETTER">Letter</option>
      </select>
      <label for="orientation">Orientation:</label>
      <select id="orientation">
        <option value="portrait">Portrait</option>
        <option value="landscape">Landscape</option>
      </select>
      <button onclick="downloadMergedPDF()">Download Merged PDF</button>
      <button onclick="viewMergedPDF()">View Merged PDF</button>
    </div>

    <div class="ad-section">
      <ins class="adsbygoogle"
           style="display:block"
           data-ad-client="ca-app-pub-2273117553145364/5191897711"
           data-ad-slot="1234567890"
           data-ad-format="auto"
           data-full-width-responsive="true"></ins>
      <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
    </div>
  </div>

  <footer>
    <p>&copy; 2025 PDF Merger Tool by Tech_Gen. All rights reserved.</p>
  </footer>

  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

    const dropZone = document.getElementById('drop-zone');
    const fileInput = document.getElementById('file-input');
    const previewContainer = document.getElementById('preview-container');
    let pdfDocs = [];

    dropZone.addEventListener('click', () => fileInput.click());
    dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.style.borderColor = '#4a90e2'; });
    dropZone.addEventListener('dragleave', () => { dropZone.style.borderColor = '#ccc'; });
    dropZone.addEventListener('drop', async e => { e.preventDefault(); dropZone.style.borderColor = '#ccc'; await handleFiles(e.dataTransfer.files); });
    fileInput.addEventListener('change', async () => await handleFiles(fileInput.files));

    async function handleFiles(files) {
      for (let file of files) {
        try {
          const arrayBuffer = await file.arrayBuffer();
          const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
          const pdf = await loadingTask.promise;
          pdfDocs.push({ file, pdf });

          for (let i = 0; i < pdf.numPages; i++) {
            const page = await pdf.getPage(i + 1);
            const viewport = page.getViewport({ scale: 1.0 }); // Increased scale for better quality
            
            // Create canvas with higher resolution
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            // Set display size
            const displayScale = 0.5;
            canvas.style.width = (viewport.width * displayScale) + 'px';
            canvas.style.height = (viewport.height * displayScale) + 'px';
            
            // Set actual size for rendering (higher resolution)
            const outputScale = window.devicePixelRatio || 1;
            canvas.width = Math.floor(viewport.width * outputScale);
            canvas.height = Math.floor(viewport.height * outputScale);
            
            // Scale the context to ensure crisp rendering
            context.scale(outputScale, outputScale);
            
            const renderContext = {
              canvasContext: context,
              viewport: viewport
            };
            
            await page.render(renderContext).promise;

            const preview = document.createElement('div');
            preview.className = 'page-preview';
            preview.draggable = true;
            preview.appendChild(canvas);

            const controls = document.createElement('div');
            controls.className = 'controls';

            const rotateBtn = document.createElement('button');
            rotateBtn.textContent = 'âŸ³';
            rotateBtn.onclick = () => {
              const angle = parseInt(canvas.dataset.angle || '0') + 90;
              canvas.style.transform = `rotate(${angle}deg)`;
              canvas.dataset.angle = angle % 360;
            };

            controls.appendChild(rotateBtn);
            preview.appendChild(controls);
            previewContainer.appendChild(preview);
          }
        } catch (error) {
          console.error('Error processing file:', error);
          alert(`Error processing ${file.name}: ${error.message}`);
        }
      }
      enableDragAndDrop();
    }

    function enableDragAndDrop() {
      let dragSrcEl;
      previewContainer.addEventListener('dragstart', e => {
        if (e.target.closest('.page-preview')) {
          dragSrcEl = e.target.closest('.page-preview');
          e.dataTransfer.effectAllowed = 'move';
        }
      });

      previewContainer.addEventListener('dragover', e => { e.preventDefault(); });

      previewContainer.addEventListener('drop', e => {
        e.preventDefault();
        const dropTarget = e.target.closest('.page-preview');
        if (dragSrcEl && dropTarget && dragSrcEl !== dropTarget) {
          previewContainer.insertBefore(dragSrcEl, dropTarget.nextSibling);
        }
      });
    }

    async function generateMergedPDFBlob() {
      const { PDFDocument, rgb } = PDFLib;
      const mergedPdf = await PDFDocument.create();

      const sizeMap = {
        A4: [595.28, 841.89],
        LETTER: [612, 792]
      };

      const pageSize = document.getElementById('page-size').value;
      const orientation = document.getElementById('orientation').value;
      let [w, h] = sizeMap[pageSize];
      if (orientation === 'landscape') [w, h] = [h, w];

      // Get selected quality
      const quality = document.querySelector('input[name="quality"]:checked').value;
      let imageQuality = 1.0;
      if (quality === 'medium') imageQuality = 0.8;
      if (quality === 'low') imageQuality = 0.6;

      const previewPages = previewContainer.querySelectorAll('.page-preview canvas');
      for (let canvas of previewPages) {
        try {
          const angle = parseInt(canvas.dataset.angle || '0');
          
          // Create a temporary canvas for quality adjustments
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          
          // Set dimensions based on quality
          tempCanvas.width = canvas.width * imageQuality;
          tempCanvas.height = canvas.height * imageQuality;
          
          // Draw with scaling for quality adjustment
          tempCtx.drawImage(canvas, 0, 0, tempCanvas.width, tempCanvas.height);
          
          // Convert to image data URL with quality setting
          const imageData = tempCanvas.toDataURL("image/jpeg", imageQuality);
          const imageBytes = await fetch(imageData).then(res => res.arrayBuffer());
          
          // Embed the image in PDF
          let image;
          if (imageData.startsWith('data:image/jpeg')) {
            image = await mergedPdf.embedJpg(imageBytes);
          } else {
            image = await mergedPdf.embedPng(imageBytes);
          }
          
          const page = mergedPdf.addPage([w, h]);
          const { width, height } = image.scaleToFit(w, h);
          const x = (w - width) / 2;
          const y = (h - height) / 2;
          
          page.drawImage(image, { 
            x, 
            y, 
            width, 
            height, 
            rotate: PDFLib.degrees(angle || 0),
            opacity: 1.0
          });
        } catch (error) {
          console.error('Error adding page:', error);
        }
      }

      return new Blob([await mergedPdf.save()], { type: 'application/pdf' });
    }

    async function downloadMergedPDF() {
      try {
        const blob = await generateMergedPDFBlob();
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'merged_document.pdf';
        link.click();
        setTimeout(() => URL.revokeObjectURL(link.href), 100);
      } catch (error) {
        console.error('Error generating PDF:', error);
        alert('Error generating PDF: ' + error.message);
      }
    }

    async function viewMergedPDF() {
      try {
        const blob = await generateMergedPDFBlob();
        const url = URL.createObjectURL(blob);
        window.open(url, '_blank');
        setTimeout(() => URL.revokeObjectURL(url), 100);
      } catch (error) {
        console.error('Error generating PDF:', error);
        alert('Error generating PDF: ' + error.message);
      }
    }
  </script>
</body>
</html>
